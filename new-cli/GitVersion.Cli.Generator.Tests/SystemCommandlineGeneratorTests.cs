using System.CommandLine;
using GitVersion.Infrastructure;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace GitVersion.Cli.Generator.Tests;

public class SystemCommandlineGeneratorTests
{
    /*language=cs*/
    private const string GlobalUsingsCode =
"""
// <autogenerated />
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
""";

    /*language=cs*/
    private const string ExpectedCommandImplText =
$$"""
{{Constants.GeneratedHeader}}
using System.CommandLine;
using System.CommandLine.Binding;

using {{Constants.CommandNamespaceName}};

namespace {{Constants.GeneratedNamespaceName}};

public class TestCommandImpl : Command, ICommandImpl
{
    public string CommandImplName => nameof(TestCommandImpl);
    public string ParentCommandImplName => string.Empty;
    // Options list
    protected readonly Option<System.IO.FileInfo?> LogFileOption;
    protected readonly Option<string> OutputFileOption;
    protected readonly Option<GitVersion.Infrastructure.Verbosity?> VerbosityOption;
    protected readonly Option<System.IO.DirectoryInfo?> WorkDirOption;

    public TestCommandImpl(TestCommand command)
        : base("test", "Test description.")
    {
        LogFileOption = new Option<System.IO.FileInfo?>("--log-file", "-l")
        {
            Required = false,
            Description = "The log file",
        };
        OutputFileOption = new Option<string>("--output-file")
        {
            Required = true,
            Description = "The output file",
        };
        VerbosityOption = new Option<GitVersion.Infrastructure.Verbosity?>("--verbosity")
        {
            Required = false,
            Description = "The verbosity of the logging information",
        };
        WorkDirOption = new Option<System.IO.DirectoryInfo?>("--work-dir")
        {
            Required = false,
            Description = "The working directory with the git repository",
        };
        Add(LogFileOption);
        Add(OutputFileOption);
        Add(VerbosityOption);
        Add(WorkDirOption);

        this.SetAction(Run);
        return;

        Task<int> Run(ParseResult parseResult, CancellationToken cancellationToken)
        {
            var settings = new TestCommandSettings
            {
                LogFile = parseResult.GetValue(LogFileOption),
                OutputFile = parseResult.GetValue(OutputFileOption)!,
                Verbosity = parseResult.GetValue(VerbosityOption),
                WorkDir = parseResult.GetValue(WorkDirOption),
            };
            return command.InvokeAsync(settings, cancellationToken);
        }
    }
}
""";

    /*language=cs*/
    private const string ExpectedCommandsModuleText =
$$"""
{{Constants.GeneratedHeader}}
using System.CommandLine;
using {{Constants.InfrastructureNamespaceName}};
using {{Constants.CommandNamespaceName}};
using {{Constants.CommonNamespaceName}};
using Microsoft.Extensions.DependencyInjection;

namespace {{Constants.GeneratedNamespaceName}};

public class CommandsModule : IGitVersionModule
{
    public IServiceCollection RegisterTypes(IServiceCollection services)
    {
        services.AddSingleton<ICliApp, CliAppImpl>();
        services.AddSingleton<RootCommandImpl>();

        services.AddSingleton<TestCommand>();
        services.AddSingleton<ICommandImpl, TestCommandImpl>();
        return services;
    }
}
""";

    /*language=cs*/
    private const string ExpectedRootCommandImplText =
$$"""
{{Constants.GeneratedHeader}}
using System.CommandLine;

using {{Constants.CommonNamespaceName}};
using {{Constants.ExtensionsNamespaceName}};

namespace {{Constants.GeneratedNamespaceName}};

public class RootCommandImpl(IEnumerable<ICommandImpl> commands) : RootCommand
{
    private readonly IEnumerable<ICommandImpl> _commands = commands.NotNull();

    public void Configure()
    {
        var map = _commands.ToDictionary(c => c.CommandImplName);
        foreach (var command in map.Values)
        {
            AddCommand(command, map);
        }
    }

    private void AddCommand(ICommandImpl command, Dictionary<string, ICommandImpl> map)
    {
        if (!string.IsNullOrWhiteSpace(command.ParentCommandImplName))
        {
            var parent = map[command.ParentCommandImplName] as Command;
            parent?.Add((Command)command);
        }
        else
        {
            Add((Command)command);
        }
    }
}
""";

    /*language=cs*/
    private const string ExpectedCliAppImplText =
$$"""
{{Constants.GeneratedHeader}}
using System.CommandLine;
using {{Constants.ExtensionsNamespaceName}};
using {{Constants.InfrastructureNamespaceName}};

namespace {{Constants.GeneratedNamespaceName}};

internal class CliAppImpl : ICliApp
{
    private readonly RootCommandImpl _rootCommand;

    public CliAppImpl(RootCommandImpl rootCommand)
    {
        _rootCommand = rootCommand.NotNull();
        _rootCommand.Configure();
    }

    public Task<int> RunAsync(string[] args, CancellationToken cancellationToken)
    {
        // Note: there are 2 locations to watch for the dotnet-suggest tool
        // - sentinel file:
        //  $env:TEMP\system-commandline-sentinel-files\ and
        // - registration file:
        //  $env:LOCALAPPDATA\.dotnet-suggest-registration.txt or $HOME/.dotnet-suggest-registration.txt

        var parseResult = _rootCommand.Parse(args);

        var logFile = parseResult.GetValue<FileInfo?>(GitVersionSettings.LogFileOption);
        var verbosity = parseResult.GetValue<Verbosity?>(GitVersionSettings.VerbosityOption) ?? Verbosity.Normal;

        LoggingEnricher.Configure(logFile?.FullName, verbosity);

        return parseResult.InvokeAsync(cancellationToken: cancellationToken);
    }
}
""";

    /*language=cs*/
    private const string TestCommandSourceCode =
$$"""
using {{Constants.InfrastructureNamespaceName}};
using Microsoft.Extensions.Logging;

namespace {{Constants.CommandNamespaceName}};

[CommandAttribute("test", "Test description.")]
public class TestCommand(ILogger logger): ICommand<TestCommandSettings>
{
  public Task<int> InvokeAsync(TestCommandSettings settings, CancellationToken cancellationToken = default)
  {
      return Task.FromResult(0);
  }
}

""";

    /*language=cs*/
    private const string TestCommandSettingsSourceCode =
$$"""
using {{Constants.InfrastructureNamespaceName}};
using Microsoft.Extensions.Logging;

namespace {{Constants.CommandNamespaceName}};

public record TestCommandSettings : GitVersionSettings
{
  [Option("--output-file", "The output file")]
  public required string OutputFile { get; init; }
}

""";

    [Test]
    public async Task ValidateGeneratedCommandImplementation()
    {
        var generatorType = typeof(SystemCommandlineGenerator);
        var sourceGeneratorTest = new CSharpSourceGeneratorTest<SystemCommandlineGenerator, DefaultVerifier>
        {
            TestState =
            {
                Sources =
                {
                    (generatorType, "GlobalUsings.cs", GlobalUsingsCode),
                    (generatorType, "TestCommand.cs", TestCommandSourceCode),
                    (generatorType, "TestCommandSettings.cs", TestCommandSettingsSourceCode)
                },
                GeneratedSources =
                {
                    (generatorType,"TestCommandImpl.g.cs", ExpectedCommandImplText),
                    (generatorType,"CommandsModule.g.cs", ExpectedCommandsModuleText),
                    (generatorType,"RootCommandImpl.g.cs", ExpectedRootCommandImplText),
                    (generatorType,"CliAppImpl.g.cs", ExpectedCliAppImplText),
                },
                ReferenceAssemblies = ReferenceAssemblies.Net.Net90,
                AdditionalReferences =
                {
                    MetadataReference.CreateFromFile(typeof(ILogger).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(IServiceCollection).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(RootCommand).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(CommandAttribute).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(IGitVersionModule).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(LoggingEnricher).Assembly.Location),
                }
            }
        };

        sourceGeneratorTest.SolutionTransforms.Add(
            // make sure the ImplicitUsage is enabled
            (solution, projectId) =>
            {
                var project = solution.GetProject(projectId)!;

                // Enable ImplicitUsings
                var parseOptions = (CSharpParseOptions)project.ParseOptions!;
                var compilationOptions = (CSharpCompilationOptions)project.CompilationOptions!;

                // Enable implicit usings (same as `<ImplicitUsings>enable</ImplicitUsings>` in .csproj)
                compilationOptions = compilationOptions.WithNullableContextOptions(NullableContextOptions.Enable);

                return project
                    .WithParseOptions(parseOptions.WithLanguageVersion(LanguageVersion.Latest))
                    .WithCompilationOptions(compilationOptions)
                    .Solution;
            });
        await sourceGeneratorTest.RunAsync();
    }
}
