using System.CommandLine;
using GitVersion.Infrastructure;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;

namespace GitVersion.Cli.Generator.Tests;

public class SystemCommandlineGeneratorTests
{
    /*language=cs*/
    private const string TestCommandSourceCode =
$$"""
using {{Content.DependencyInjectionNamespaceName}};

namespace {{Content.CommandNamespaceName}};

public record TestCommandSettings
{
    [Option("--output-file", "The output file")]
    public required string OutputFile { get; init; }
}

[CommandAttribute("test", "Test description.")]
public class TestCommand(ILogger logger): ICommand<TestCommandSettings>
{
    public Task<int> InvokeAsync(TestCommandSettings settings, CancellationToken cancellationToken = default)
    {
        return Task.FromResult(0);
    }
}

""";

    /*language=cs*/
    private const string GlobalUsingsCode =
"""
// <autogenerated />
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
""";

    /*language=cs*/
    private const string ExpectedCommandImplText =
$$"""
{{Content.GeneratedHeader}}
using System.CommandLine;
using System.CommandLine.Binding;

using {{Content.CommandNamespaceName}};

namespace {{Content.GeneratedNamespaceName}};

public class TestCommandImpl : Command, ICommandImpl
{
    public string CommandName => nameof(TestCommandImpl);
    public string ParentCommandName => string.Empty;
    // Options list
    protected readonly Option<string> OutputFileOption;

    public TestCommandImpl(TestCommand command)
        : base("test", "Test description.")
    {
        OutputFileOption = new Option<string>("--output-file", [])
        {
            Required = true,
            Description = "The output file",
        };
        Add(OutputFileOption);

        this.SetAction(Run);
        return;

        Task<int> Run(ParseResult parseResult, CancellationToken cancellationToken)
        {
            var settings = new TestCommandSettings
            {
                OutputFile = parseResult.GetValue(OutputFileOption)!,
            };
            return command.InvokeAsync(settings, cancellationToken);
        }
    }
}
""";

    /*language=cs*/
    private const string ExpectedCommandsModuleText =
$$"""
{{Content.GeneratedHeader}}
using System.CommandLine;
using {{Content.DependencyInjectionNamespaceName}};
using {{Content.CommandNamespaceName}};
using {{Content.InfraNamespaceName}};

namespace {{Content.GeneratedNamespaceName}};

public class CommandsModule : IGitVersionModule
{
    public void RegisterTypes(IContainerRegistrar services)
    {
        services.AddSingleton<RootCommandImpl>();
        services.AddSingleton<TestCommand>();
        services.AddSingleton<ICommandImpl, TestCommandImpl>();
    }
}
""";

    /*language=cs*/
    private const string ExpectedRootCommandImplText =
$$"""
{{Content.GeneratedHeader}}
using System.CommandLine;

using {{Content.InfraNamespaceName}};
namespace {{Content.GeneratedNamespaceName}};

public class RootCommandImpl : RootCommand
{
    public RootCommandImpl(IEnumerable<ICommandImpl> commands)
    {
        var map = commands.ToDictionary(c => c.CommandName);
        foreach (var command in map.Values)
        {
            AddCommand(command, map);
        }
    }
    private void AddCommand(ICommandImpl command, IDictionary<string, ICommandImpl> map)
    {
        if (!string.IsNullOrWhiteSpace(command.ParentCommandName))
        {
            var parent = map[command.ParentCommandName] as Command;
            parent?.Add((Command)command);
        }
        else
        {
            Add((Command)command);
        }
    }
}
""";

    [Test]
    public async Task ValidateGeneratedCommandImplementation()
    {
        var generatorType = typeof(SystemCommandlineGenerator);
        var sourceGeneratorTest = new CSharpSourceGeneratorTest<SystemCommandlineGenerator, DefaultVerifier>
        {
            TestState =
            {
                Sources =
                {
                    (generatorType, "GlobalUsings.cs", GlobalUsingsCode),
                    (generatorType, "TestCommand.cs", TestCommandSourceCode)
                },
                GeneratedSources =
                {
                    (generatorType,"TestCommandImpl.g.cs", ExpectedCommandImplText),
                    (generatorType,"CommandsModule.g.cs", ExpectedCommandsModuleText),
                    (generatorType,"RootCommandImpl.g.cs", ExpectedRootCommandImplText),
                },
                ReferenceAssemblies = ReferenceAssemblies.Net.Net90,
                AdditionalReferences =
                {
                    MetadataReference.CreateFromFile(typeof(ILogger).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(RootCommand).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(CommandAttribute).Assembly.Location),
                }
            }
        };

        sourceGeneratorTest.SolutionTransforms.Add(
            // make sure the ImplicitUsage is enabled
            (solution, projectId) =>
            {
                var project = solution.GetProject(projectId)!;

                // Enable ImplicitUsings
                var parseOptions = (CSharpParseOptions)project.ParseOptions!;
                var compilationOptions = (CSharpCompilationOptions)project.CompilationOptions!;

                // Enable implicit usings (same as `<ImplicitUsings>enable</ImplicitUsings>` in .csproj)
                compilationOptions = compilationOptions.WithNullableContextOptions(NullableContextOptions.Enable);

                return project
                    .WithParseOptions(parseOptions.WithLanguageVersion(LanguageVersion.Latest))
                    .WithCompilationOptions(compilationOptions)
                    .Solution;
            });
        await sourceGeneratorTest.RunAsync();
    }
}
